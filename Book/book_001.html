<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>연습</title>
</head>
<body>
    <script>

        // console.log("안녕하세요.");
        // console.error("에러메시지 출력시 사용");
        // console.warn("경고 메시지 출력시 사용");

//--------%c css적용---------------------------------------------------

        // console.log("%cHello %cY-Y %cDigital HighSchool",
        //             "color:#c71919; font-size:20px;",
        //             "color:#2196f3; font-size:25px;",
        //             "color:#ffa726; font-size:18px");
        
//--------typeof---------------------------------------------------

        // var number = 1;
        // var string = "Hello world";
        // console.log("number의 타입 : " + typeof number);
        // console.log("string의 타입 : " + typeof string);
        // number = "문자열로 변경됩니다.";
        // string = 1;
        // console.log("number의 타입 : " + typeof number);
        // console.log("string의 타입 : " + typeof string);        
        
//----------형변환-------------------------------------------------

        // var numString = "123456";
        // console.log(numString[0]); //1출력
        // console.log(numString[1]); //2출력
        // console.log(numString[2]); //3출력
        // let a = numString[3]; //4출력
        // let b = numString[4]; //5출력
        // console.log(a * b); 
        // console.log(a + 10);
        
//-----------------------------------------------------------

        // console.log(a);
        // var a;

        // console.log(a);
        // let a;

//-----------------------------------------------------------

        // const a = 10;
        // let b = 10;
        // console.log(a, b);
        // b = 20;
        // console.log(a, b);
        // a = 30;
        // console.log(a, b);  //여기서 에러 발생

//-----------------------------------------------------------

        // let person = {};
        // console.log(person);
        // console.log(typeof person);
        
//-----------------------------------------------------------

        // let person = {
        //     "name" : "최선한",
        //     "age" : 30,
        //     "phone" : "010-0000-0000"
        // };
        // console.log(person.name);
        // console.log(person.age);
        // console.log(person.phone);
        
//-----------------------------------------------------------

        // let person1 = {
        //     "p name" : "박은서",
        //     age : 19,
        //     phone : "010-1234-1234"
        // };

        // //p name 속성은 띄어쓰기가 들어가 있기 때문에 큰 따옴표를 생략할 수 없다.
      
        // console.log(person["p name"]);

        // //띄어쓰기가 들엉간 속성은 위와 같이 대괄호 연산자를 이용해서 접근이 가능하다.
        // console.log(person.age);
        // console.log(person.phone);

//-----------------------------------------------------------

        //   const person = { name : "최선한"};
          
        //   person.name = "변경된이름"; //허용가능하다.
        //   console.log(person);

        //   person = {name : "변경된 객체"}; //불가능하다.
        //   console.log(person);

//-----------------------------------------------------------

            // let value = prompt("값을 입력하세요." , "기본값");
            // console.log(value);

//-----if------------------------------------------------------

            // let result = "";
            // let value = prompt("값을 입력하세요.", 0);
            // value = parseInt(value); // 입력받은 문자열은 숫자로 변환된다.
            // if(value > 10){
            //     result = "입력하신 값은 10보다 큽니다.";
            // } else{
            //     result = "입력하신 값은 10보다 작거나 같습니다.";
            // }
            // console.log(result);

//-----for------------------------------------------------------

            // for(let i = 0; i < 10; i++){
            //     console.log(i);
            // }    

//-----while------------------------------------------------------

            // let i = 0;
            // while(i < 10){
            //     console.log(i);
            //     i++;
            // }

//-----배열 선언 방법------------------------------------------------------

            // let a = new Array();
            // let b = [];

//-----배열------------------------------------------------------

            // let a = [];
            // a.push(1);
            // a.push("문자열");
            // a.push(true);
            // a.push(22.3333);
            // console.log(a);

            // let a = [1, "문자열", true, 22.3333];

            // for(let i = 0; i < a.length; i++){
            //     console.log(a[i]);
            // }

//-----배열값 변경------------------------------------------------------

            // let a = [1, "문자열", true, 22.3333];

            // //0번째와 1번째의 값을 변경시킵니다.
            // a[0] = "변경된 값";
            // a[1] = 34;
            // for(let i = 0; i < a.length; i++){
            //     console.log(a[i]);
            // }

//-----배열 삭제------------------------------------------------------

            // let a = [1, "문자열", true, 22.3333];

            // delete a[1]; //1번 원소를 삭제합니다.
            // console.log(a);

            // let a = [1, "문자열", true, 22.3333];
            // let cut = a.splice(1, 2); //1번 인덱스부터 2개 삭제
            // console.log(cut); //잘려져 나간 ["문자열", true]
            // console.log(a); // 남아 있는 [1, 22.3333]

//--------(concat) => 배열을 붙여줌--------------------------------------

            // let a = [1, 2, 3, 4];
            // let b = [5, 6, 7, 8];
            // let c = a.concat(b);

            // console.log(c);

//--------indexOf와 lastIndexOf--------------------------------------

            //각각 해당하는 원소가 첫 번째로 나오는 위치와 마지막으로 나온 위치를 알려주는 메서드임
            // let arr = ["최선한", "양영", "디치털", "기능반", " 웹" ,"최선한"];
            // console.log("최선한의 위치 : " + arr.indexOf("최선한"));
            // console.log("최선한의 위치 : " + arr.lastIndexOf("최선한"));
  

 //--------indexOf와 lastIndexOf-------------------------------------- 

            // shift와 pop은 각각 배열의 처움과 끝에서 원소를 제거하는 역할을 함
            // let arr = ["최선한" , "양영", "디지털", "기능반", "웹"];
            // let item = arr.shift();
            // console.log(item); //첫번째 원소를 뺏으니 "최선한"이 나옵니다.
            // console.log(arr);
            // item = arr.pop();
            // console.log(item); //마지막 원소를 뺐으니 "웹"이 나옵니다.
            // console.log(arr);

  //---------객체----------------------------------------------------           

            // let human = {
            //     name : "최선한",
            //     age : 30,
            //     hobbies : ["프로그래밍", "게임", "육아"]
            // }
            
            // console.log(human);

  //---------ES7 조립분해--------------------------------------------------------   

            // let human = {name : "최선한", age : 30,};
            // let {name, age} = human;
            // console.log(name, age);

//----------함수 예제------------------------------------------------------------

            // let result = add(3, 4);
            // console.log(result);

            // function add(a, b){
            //     return a + b;
            // }
                
//----------권장되지 않는 함수 선언 예제------------------------------------------

            // let flag = 9;

            // if(flag < 10){
            //     let result = add(3, 4);
            //     console.log(result);
            //     function add(a, b){
            //         return a + b;
            //     }
            // }
            // let  result = add(4, 5);
            // console.log(result);

 //----------함수의 매개변수(1)------------------------------------------------------------           

            // function add(a, b){
            //     return a + b;
            // }
            // console.log(add(3));
            // //b는 undefined로 처리되어 넘어가고 결과는 NaN이다.
            // //NaN은 Not a Number의 약자로 숫자형이지만 숫자가 아닌 값이라는 뜻이다.
            // //주로 숫자의 크기를 초과하는 값이 넘어오거나 숫자와 숫자가 아닌 것을 연산했을때 발생함
            
            // console.log(add(3, 4, 5, 6, 7));
            // //앞서 넘어온 3, 4만이 a, b에 매칭되어 7을 출력하고 나머지 값은 무시된다.
            // console.log(add());
            // //이번에도 a, b 모두 undefined로 처리되어 결과는 NaN이 나온다.

 //----------함수의 매개변수(2)------------------------------------------------------------  

            // function add(a, b){
            //     console.log(arguments);
            //     return a + b;
            // }

            // console.log(add(3, 4, 5, 6, 7));

 //----------함수의 매개변수(2-1) 매개변수의 개수를 이용한 오버로딩---------------------------

            // function add(){
            //     if(arguments.length == 0){
            //         return 0;
            //     } else if(arguments.length == 1){
            //         return arguments[0];
            //     } else if(arguments.length == 2){
            //         return arguments[0] + arguments[1];
            //     } else{
            //         return -1;
            //     }
            // }

//-----------값 전달방식-----------------------------------------------------------------

            // function mod(value){
            //     value = vlaue -5;
            //     return value;
            // }

            // let a = 5; 
            // mod(a);
            // console.log(a);

//----------참조에 의한 전달----------------------------------------------------------

            // function splice(arr){
            //     arr.pop();
            // }

            // let a = [1, 2, 3, 4, 5];
            // splice(a);
            // console.log(a);

//----------얕은 복사 방식----------------------------------------------------------

            // let a = [1, 2, 3, 4, 5];
            // let b = a;

            // b[3] = 10;

            // console.log(b);
            // console.log(a);

            //결과는 a, b가 같다.
            //a, b가 같은 배열을 가르키기 때문이다.

//----------깊은 복사 방식----------------------------------------------------------

            // let a = [1, 2, 3, 4, 5];
            // let b = a.slice(0);

            // b[3] = 10;

            // console.log(b);
            // console.log(a);

            //slice에 첫번째 파리미터인 0은 생략시 자동으로 0이 입력되기 때문에 생략이 가능하다.
            //이렇게 하면 복사한 배열이 완전히 새로운 배열이 생성되기 때문에 깊은 복사가 되는 것이다.
            //다만 배열안에 내용이 오브젝트일경우 달라진다.

//---------- setInterval(수행할 함수, 인터벌시간) ------------------------------------

            // function skill(){
            //     console.log("Hello World");
            // }
            // setInterval(skill, 1000);

            //1초 한번씩 skill함수가 실행됨
            //이미 만들어진 함수를 setInterval이 호출하도록 함

//-----------익명함수-----------------------------------------------------------------            

            // setInterval(function (){
            //     console.log("Hello World");
            // }, 1000);

            //위 코드와 동일한 기능을 수행한다.

//-----------익명함수를 화살표함수로 표현하기-----------------------------------
          
            // setInterval(()=>{
            //     console.log("Hello World");
            // }, 1000);

            //function을 빼고 => 기호를 넣는다.

//--------------------------------------------------------------------------

            // [원본코드]
            // function (a){
            //     return a + 4;
            // }

            // [function 예약어를 없애고 => 기호를 추가]
            // (a) => {
            //     return a + 4;
            // }

            // [넘겨주는 파라미터가 한 개 밖에 없을 경우 소괄호를 생략 가능]
            // a => {
            //     return a + 4;
            // }

            // [함수의 몸통이 return 문 하나라면 중괄호, return문과 세미콜론을 생략 가능]
            // a => a+ 4;

            // 주의!! 화살표 함수는 익명함수만을 변경할 수 있다. 
            // 일반 함수는 익명함수로 변화시킬 수 없다.

//----------filter 함수----------------------------------------------------------------       

            // let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
            // let evenArr = arr.filter(function( x ){
            //     if(x % 2 == 0){
            //         return true;
            //     } else{
            //         return false;
            //     }
            // });
            // console.log(evenArr);
            
            //x는 배열안에 있는 모든 원소를 순차적으로 대입시킨다.
            // 중요!! 원본 배열 arr은 변함 없다. filter 메서드는 완전히 새로운 배열을 반환하기 때문이다.
            
            // let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
            // let evenArr = arr.filter( x => x % 2 == 0);
            // console.log(evenArr);

            //위 코드와 같은 기능을 하지만 화살표 함수로 표현하였다.

//---------콜백 함수에서 인덱스 활용하기-----------------------------------------------

            // let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
            // arr = arr.filter((x, i) => i % 2 == 0 && x % 2 == 1);
            // console.log(arr);
            
            //인덱스가 짝수번째에 있는 값들중에서 홀수 인 값을 출력한다. 
            //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 배열값
            //[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] index값

//---------Map 함수 사용하기-----------------------------------------------

        //     let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        //     let powerArr = arr.map( x => x * x);
        //     console.log(powerArr);

        //     let evenArr = arr.map(x => x * x).filter(x => x % 2 == 0);
        //     console.log(evenArr);  

//---------find와 findIndex의 차이점-----------------------------------------------  

        // let list = [
        //         {name : "최선한", age : 30, hobbies : ["게임", "독서"]},
        //         {name : "홍길동", age : 15, hobbies : ["혁명", "도둑질"]},
        //         {name : "이순신", age : 40, hobbies : ["왜구격퇴", "거북선건조"]},
        //         {name : "김좌진", age : 30, hobbies : ["독립운동"]}
        // ];

        // let item = list.find(x => x.name == "홍길동");
        // console.log(item); // 해당 값을 출력
        // let idx = list.findIndex(x  => x.name == "홍길동");
        // console.log(idx); // 해당 위치 값을 출력
        
//----------reduce를 이용한 배열의 원소 합치기------------------------------------------        

        // let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];        
        // let result = arr.reduce( (s, x) => s + x, 0); //s는 결과값 x는 배열안에 원소
        // console.log(result); // result가 누적의 성격을 가지고 있다.

//----------filter와 reduce 연계하여 사용하기-----------------------------------------

        // let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        // let result = arr.filter( x => x % 2 == 0).reduce((s, x) => s + x);
        // console.log(result);

//----------reduce를 이용한 그룹화 전략 코드----------------------------------------

        // let users = [
        //        {id : 11, name : 'Adam', age : 23, group : 'editor'},
        //        {id : 47, name : 'John', age : 28, group : 'admin'},
        //        {id : 85, name : 'William', age : 34, group : 'editor'},
        //        {id : 97, name : 'Oliver', age : 28, group : 'admin'}
        // ];
        
        // let groupByAge = users.reduce((result, user) => {
        //         let cnt = (result[user.age] || 0) + 1;
        //         result[user.age] = cnt;
        //         return result;
        // }, {});

        // console.log(groupByAge);
        
//-------- 위 코드를 오브젝트 구조분해할당을 활용하여 단축시킨 코드---------------

        // let users = [
        //         {id : 11, name : 'Adam', age : 23, group : 'editor'},
        //         {id : 47, name : 'John', age : 28, group : 'admin'},
        //         {id : 85, name : 'William', age : 34, group : 'editor'},
        //         {id : 97, name : 'Oliver', age : 28, group : 'admin'}
        // ];
        
        // let groupByAge = users.reduce((result, user) => ({ 
        //         ...result, [user.age] : (result[user.age] || 0) + 1}),{});

        // console.log(groupByAge);

//--------배열 구조 분해 할당-----------------------------------------------------

        // let arr = [10, 20, 30, 40, 50, 60];
        // [a ,b, ...rest] = arr;
        // console.log(a);
        // console.log(b);
        // console.log(rest);       

        // 앞에 변수들을 쓰고 뒤에 배열을 써주면 배열이 있는 원소들이 각각의 변수로 할당되어 
        // 들어간다. 전개연산자를 통해 남은 것을 자동을 받게 해주면 rest는 남은 원소들의 
        //배열로 만들어지게 된다. 
        
        // 전개연산자는 해당 배열이나 객체의 속성을 전개해서 나열하는 것.
        //주로 함수의 파라미터로 값을 넘길때 사용


//--------오브젝트 구조 분해 할당------------------------------------------------

        // let user = {id : 11, name : 'Adam', age : 23, group : 'editor'};
        // let {id, name} = user;
        // console.log(id, name);

        // id와 name속성 값을 따로 뽑아내어 id, name이라는 별도의 변수로 변경하는 것

//----------오브젝트 분해후 새로운 오브젝트로 만들기-----------------------------

        // let user = {id : 11, name : 'Adam', age : 23, group : 'editor'};
        // let newUser = {...user, job : "orpgrammer" , gender : 'male'};
        // console.log(newUser);

        // user를 분해하여 각 속성들을 전개한뒤 job과 gender라는 속성을 추가

//---------오브젝트에 map을 활용-------------------------------------------
                
        // let users = [
        //         {id : 11, name : 'Adam', age : 23, group : 'editor'},
        //         {id : 47, name : 'John', age : 28, group : 'admin'},
        //         {id : 85, name : 'William', age : 34, group : 'editor'},
        //         {id : 97, name : 'Oliver', age : 28, group : 'admin'}
        // ];

        // users = users.map (item => ({...item, 'adult' : item.age >= 20}) );
        // console.log(users);

//--------배열 검색---------------------------------------------------------

        // let users = [
        //         {id : 11, name : '최선한', age : 23, group : 'editor'},
        //         {id : 47, name : '강영미', age : 28, group : 'admin'},
        //         {id : 85, name : '강미선', age : 34, group : 'editor'},
        //         {id : 97, name : '전재남', age : 28, group : 'admin'},
        // ];

        // let res = users.filter(user => user.name.includes('미'));
        // console.log(res);

        // 배열내의 오브젝트중 특정값을 포함하는 원소를 검색하는 코드

//--------2차원 배열을 1차원 배열로 만들기---------------------------------       

        // let sArr = [
        //         [1, 2, 3],
        //         [4, 5, 6],
        //         [7, 8, 9]
        // ];
        
        // let flat = sArr.reduce( (r, item) => [...r, ...item],[]);
        // console.log(flat);

        //위 코드는 전개 연산자를 이용, 이전 배열을 전개하고 
        // 현재 배열을 전개해서 새로운 배열을 만든다.
        // 매 루프마다 새로운 배열을 생성하고 각각의 배열을 루프를 돌게 되어 속도면에서 효율적이지 못하다.

//-------위 코드를 효율적으로 작성하기---------------------------------------

        // let sArr = [
        //         [1, 2, 3],
        //         [4, 5, 6],
        //         [7, 8, 9]
        // ];

        // let flat = [].concat.apply([], sArr);
        // console.log(flat);
        
        // 출력값은 위 코드와 같다.
        // 비어있는 배열의 concat 매서드를 호출함
        // 이 때 apply는 호출시 this로 사용될 파라미터와 배열 값을 받게 됨
        // 자바스크립트는 this와의 싸움이라고 한다. (뭔말인지 모르겠음ㅎㅎ)

//----------전개연산의 사용여부에 따른 flat의 속도 비교-----------------------

        // let sArr = [];
        // let idx = 1;
        
        // //매우 큰 2차원 배열을 만들어준다.
        
        // for(let i = 0; i < 1000; i++){
        //         let temp = [];
        //         for(let j = 0; j < 10; j++){
        //                 temp.push(idx++);
        //         }
        //         sArr.push(temp);
        // }

        // let start = new Date().getTime();
        // let flat = sArr.reduce( (r, item) => [...r, ...item]);
        // let elapsed = new Date().getTime() - start;
        // console.log("수행시간 : " + elapsed + "ms");
        // start = new Date().getTime();
        // flat = [].concat.apply([], sArr);
        // elapsed = new Date().getTime() - start;
        // console.log("수행시간 : " + elapsed + "ms");
        // start = new Date().getTime();
        // flat = [].concat(...sArr);
        // elapsed = new Date().getTime() - start;
        // console.log("수행시간 : " + elapsed + "ms");

//---------배열안의 오브젝트의 특정값을 기반으로 배열을 인덱스화 시키기---------

        // let users = [
        //         {id : 11, name : 'Adam', age : 23, group : 'editor'},
        //         {id : 47, name : 'John', age : 28, group : 'admin'},
        //         {id : 85, name : 'William', age : 34, group : 'editor'},
        //         {id : 97, name : 'Oliver', age : 28, group : 'admin'}
        // ]; 

        // 이 데이터에서 id가 47번인 사람을 찾으려면 배열을 for문으로 일치하는 
        //값이 나올때까지 돌거나 find메서드를 이용해야한다.

        // let date = {
        //         11 : {id : 11, name : 'Adam', age : 23, group : 'editor'},
        //         47 : {id : 47, name : 'John', age : 28, group : 'admin'},
        //         85 : {id : 85, name : 'William', age : 34, group : 'editor'},
        //         97 : {id : 97, name : 'Oliver', age : 28, group : 'admin'}
        // }; 

        // 위와 같은 형태로 데이터를 변화시키면 좀 더 효율적으로 데이터를 찾을 수 있게된다.

//--------배열을 키를 가진 오브젝트로 변화시키기-------------------------------

        // let users = [
        //         {id : 11, name : 'Adam', age : 23, group : 'editor'},
        //         {id : 47, name : 'John', age : 28, group : 'admin'},
        //         {id : 85, name : 'William', age : 34, group : 'editor'},
        //         {id : 97, name : 'Oliver', age : 28, group : 'admin'}
        // ]; 

        // users = users.reduce( (r, x) => ({...r, [x.id] : x}), {});
        // console.log(users);

//-----------Set의 예제-----------------------------------------------------

        // let a = new Set([1, 2, 2, 2, 2, 1, 1, 3, 4, 2, 3, 4, 5]);
        // console.log(a);

        // Set은 배열내에서 중복된 것들을 제외하고 아이템을 만들어준다.
       

//-----------Set을 배열로 변환하기-------------------------------------------

        // let a = new Set([1, 2, 2, 2, 2, 1, 1, 3, 4, 2, 3, 4, 5]);
        // a = [...a];
        // console.log(a);

        // Set을 다시 배열로 변경하기위해서는 위와 같이 전개식을 사용하면 된다.
        
//--------Set을 활용해 중복된 값 제거하기----------------------------------

        // let users = [
        //         {id : 11, name : 'Adam', age : 23, group : 'editor'},
        //         {id : 47, name : 'John', age : 28, group : 'admin'},
        //         {id : 85, name : 'William', age : 34, group : 'editor'},
        //         {id : 97, name : 'Oliver', age : 28, group : 'admin'}
        // ]; 

        // let date = [...new Set(users.map(x => x.group))];
        // console.log(date);

//---------키 value 역전시키기--------------------------------------------

        // let cities = {
        //         Seoul : '대한민국',
        //         Busan : '대한민국',
        //         Berlin : '독일',
        //         Paris : '프랑스',
        //         Lyon : '프랑스' 
        // };

        // // 위 코드를 key:value 형식으로 데이터를 변형한것이 밑에 코드이다.
        // // 내 생각에는 둘다 비슷하다.

        // let date = {
        //         '대한민국' : ['Seoul', 'Busan'],
        //         '독일' : ['Berlin'],
        //         '프랑스' : ['Paris', 'Lyon']
        // };

//----------reduce를 이용한 요브젝트 키 역전-----------------------------

        // let cities = {
        //         Seoul : '대한민국',
        //         Busan : '대한민국',
        //         Berlin : '독일',
        //         Paris : '프랑스',
        //         Lyon : '프랑스' 
        // };

        // //cities 오브젝트에 있는 모든 키를 빼내서 배열로 만든다.
        // let list = Object.keys(cities);

        // //(ver1)
        // // let data = list.reduce( (r, x) => {
        // //         r[cities[x]] = [...(r[cities[x]] || []), x];
        // //         return r;
        // // }, {});

        // //(ver2) 위 코드와 같은 결과를 출력하지만 더 짧다능
        // // 근데 너무 단축하여서 코드의 가독성이 많이 떨어진다고 한다.
        // let data = list.reduce( (r, x) => (r[cities[x]] = [...(r[cities[x]] || []), x] ,r), {});

        // console.log(data);
        
//---------객체를 쿼리스트링으로 변환하기---------------------------------------

        // let params = {let : 45, lng : 6, alt : 1000};
        // let queryString = Object.entries(params).map(
        //         p => encodeURIComponent(p[0]) + '=' + encodeURIComponent(p[i])).join('&');
        //         //"let=45&lng=6&alt=1000"
        //         console.log(queryString);
        
        // // 키와 값을 = 기호로 묶고 그렇게 묶여진 데이터를 다시 & 로 join하여
        // // 묶음으로서 쿼리 스트링 형태의 데이터를 만듦
        
//--------String template----------------------------------------------------------

        // let link = "http://www.naver.com";
        // let text = "링크입니다.";
        // let className = "on";

        // // let html = "<div><a href='" + link + "' class='" + className + "'>" + text + "</a></div>";

        // let html = `<div><a href='${link}' class='${className}'> ${text} </a></div>`;

        // function makeTemplate({id, title, content}){
        //         let div = document.createElemet("div");
        //         div.innerHTML = 
        //                 `<div class="item" date-id="${id}">
        //                 <h4 class="title"> ${title}</h4>
        //                 <span class="msg">${content}</span>
        //                 </div>`;

        //         return div.firstChild;
        // }


    </script>


</body>
</html>